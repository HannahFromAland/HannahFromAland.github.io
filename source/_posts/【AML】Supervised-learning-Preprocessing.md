---
title: 【AML】Supervised Learning & Preprocessing
date: 2022-03-05 18:09:26
tags: AML
category: Machine Learning
---
### Supervised Learning

监督学习内部分为分类问题（classification）和回归问题（regression）两类。分类问题的输出标签为离散值，回归问题可以理解为连续问题。

监督学习的关键在于得到一般化的（generalized）的模型，因为监督学习的目的是为了利用已知的训练集特征和标签/输出值来获得对未知的测试集进行尽可能准确的预测。因此会存在欠拟合或过拟合的问题。

<!-- more -->

#### Framework of Supervised Learning

![](https://s2.loli.net/2022/03/06/QMycfnUvRXjP27x.png)

- Validation data 和 test data的区别？
  - Validation data是development data的一部分，必须是带有样本输出标签的数据。Validation data的主要作用是进行超参数调整以选出最佳模型参数，在调整参数的过程中用于不同参数表现的评估
  - Test data是在选定最终模型之后进行模型评估的数据集。Test data用于评估被选中的模型在真实数据集上的表现，即上文提到的generalize的能力。
- 无监督学习能否使用该流程？
  - 不能。因为无监督学习没有带输出标签的数据，无法实现上述的调参模式。

#### Development-test split

主要有三种划分测试集的方法：

- Random Splitting: 直接从数据集中抽取所需比例的随机数据作为测试集
- Stratified Splitting: 从不同的输出标签集合中等比例进行测试数据的抽取。较为不平衡的数据可以通过分层抽样实现测试集的样本平衡
- Structured Splitting: 按照某一顺序对数据进行分类，适用于时间序列数据。防止使用时间靠后的数据进行训练而“预测"过去发生的事情出现数据泄漏的情况（data leakage）

#### Hyperparameter tuning

超参数指的是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。比如决策树模型中数的最大深度，KNN模型中k的值。超参数的选取和模型的复杂程度有直接的关系。同样以决策树为例，如果设定的最大深度过大以实现叶节点的purity，则可能会使模型出现过拟合的现象。

常用的选择超参数/超参数组合的方法有Grid Search & Random Search （网格搜索或随机搜索）及Bayesian Optimization （贝叶斯优化）（见下一小节）

进行超参数调整的最终目的是为了实现模型的优化和选择。主要的模型选择及验证集构建的方法有如下几种：

- Three-way holdout: 最朴素的将数据集拆分为构建集和测试集，再将构建集拆分为训练集和验证集的方法。利用训练集和验证集进行超参数调整和模型选择
- K-fold CV （K折交叉验证）：将构建集随机等分成k份，每次选取1份作为验证集并用剩余k-1份进行训练，输出的训练结果为k次验证的平均表现。结合前述数据集划分的不同方式，k折交叉验证也可以适用于stratified sampling。
- Leave-one-out CV ：即k折交叉验证中K=构建集数据总数n的特例。相当于每次拿n-1的数据进行训练并使用1条数据进行验证，以最大化训练集的数目。


#### Grid Search & Random Search

**网格搜索（Grid Search）**：本质上是穷举法，即预先给出各个参数的有限集/取值列表进行组合训练，选出验证集误差最小的超参数作为最好的超参数。方法的弊端十分明显，即当超参数备选集取值增加时复杂度是指数级别增长的，因此一般只能适用于优化三个或者更少数量的超参数；此外网格搜索针对非凸问题易得到局部最优解。

**随机搜索（Random Search）**：随机搜索会尝试 n 次的随机猜测，每次尝试的过程如下：

- 在超参数的预设区间内生成一个随机解
- 随后使用成本函数评估成本
- 与目前为止的最优解比较成本，如果成本更低则更新最优解及最优成本。
- 虽然随机搜索得到的结果互相之间差异较大，但是实验证明随机搜索的确比网格搜索效果要好。

在实际操作中可以通过组合两种搜索算法的方式来获得更优表现：首先使用随机搜索确定表现较好的超参数区间，在缩小范围内进行网格搜索以快速获得最优解

#### Bayesian Optimization

假设一组超参数组合是$𝑋=x_1, x_2, x...x_n $($x_n$表示某一个超参数的值)，不同超参数会得到不同效果，贝叶斯优化假设超参数与最后我们需要优化的损失函数存在一个函数关系，而我们需要找到使得该函数取值最大的$x^*$。
与上面的两种方法相比，贝叶斯优化最大的不同点是考虑了之前的参数信息并不断更新先验。


### Preprocessing

对数据集进行预处理时将特征分为连续特征和分类特征。针对连续特征最关键的预处理即为归一化（regularity）。
#### Continuous Feature: Scaler
- 为什么需要进行归一化？
  - 一些分类器需要计算样本之间的 **距离** （如欧氏距离），例如KNN。如果一个特征值域范围非常大，那么距离计算就主要 **取决于这个特征** ，从而与实际情况相悖（比如这时实际情况是值域范围小的特征更重要）
![image.png](https://s2.loli.net/2022/03/07/6WTMPG3Vmh7ujSn.png)

蓝色代表特征的等高线。在未归一化的情况下左图的两特征等高线相差较大，在进行度下降法寻求最优解时，很有可能走“之字型”路线（垂直等高线走），从而导致需要迭代很多次才能收敛； 而右图对两个原始特征进行了归一化，其对应的等高线显得很圆，在梯度下降进行求解时能较快的收敛。因此如果机器学习模型使用梯度下降法求最优解时，归一化往往非常有必要，否则很难收敛甚至不能收敛。

- 归一化的类型
  - Standard scaler：转化函数为$\frac{x-\mu}{\theta}$, 经过处理的数据符合标准正态分布，即均值为0，标准差为1.
  - Min-max scaler: 转化函数为$\frac{x - min}{max - min}$,适用在数值比较集中的情况。该方法的缺陷在于如果max和min不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。实际使用中可以用经验常量值来替代max和min
  - Max-absolute scaler: 转化函数为$\frac{x}{max(abs(x))}$.将值缩放到[-1,1]区间内, 不会破坏矩阵的稀疏性，因此比较适合稀疏矩阵和均值在0附近的值
  - Non-linear scaler: 经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括 log、指数，正切等

- 归一化使用注意事项：在实际预处理中，为了防止数据泄露，应使用训练集数据构建Scaler，在验证集/测试集上进行归一化。

- 面试相关问题：
  - Q: 哪些机器学习算法不需要做归一化处理？ 
  A: 树模型不需要归一化。更广义地说，概率模型不需要归一化。因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率。而像svm、KNN、KMeans之类的最优化问题就需要归一化。 
  
    树模型不需要归一化的原因是数值缩放不影响分裂点位置。因为当树的一个节点分裂时，都是按照特征的值进行排序的。如果排序的顺序不变，那么分裂点就不会有不同。但是对于线性模型，比如说LR，有两个特征，一个是(0,1)的，一个是(0,10000)的，这样运用梯度下降时候，损失等高线是一个椭圆的形状，这样想迭代到最优点，就需要很多次迭代，但是如果进行了归一化，那么等高线就是圆形的，那么SGD就会往原点迭代，需要的迭代次数较少。 另外，注意树模型是不能进行梯度下降的，因为树模型是阶跃的，阶跃点是不可导的，并且求导没意义，所以树模型（回归树）寻找最优点是通过寻找最优分裂点完成的。   
  - Q: SVM和LR需要不需要归一化？ 
  A: 有些模型在各维度进行了不均匀的伸缩后，最优解与原来不等价（如SVM）需要归一化。有些模型伸缩有与原来等价，比如LR。但是实际中往往通过迭代求解模型参数，如果目标函数太扁（想象一下很扁的高斯模型）迭代算法会发生不收敛的情况，所以最好进行数据归一化。 补充：其实本质是由于loss函数不同造成的，SVM用了欧拉距离，如果一个特征很大就会把其他的维度dominated。而LR可以通过权重调整使得损失函数不变。

#### Categorial Feature: encoding
常用的encoding方式有以下三种：
- Ordinal Encoding（序数编码）: 即将分类编码为数值，适用于二元的变量或分类本身有定性排序的情况。
- One-hot Encoding（独热编码）: One-Hot 编码会创建新列，指示原始数据中每个可能值的存在（或不存在）。与序数编码相比，one-hot 编码不假设类别的排序。
  - `OHE`的缺陷也很明显，编码后会使得空间维度大大增加，尤其是在类别很多的时候，这大大地扩展特征空间，使得训练难以进行。
  - 对数值大小不敏感的模型（如树模型）不建议使用。一般这类模型为树模型。如果分类类别特别多，那么`OHE`会分裂出很多特征变量。这时候，如果我们限制了树模型的深度而不能向下分裂的话，一些特征变量可能就因为模型无法继续分裂而被舍弃损失掉了。
  - `OHE` 在对n个分类进行n维稀疏的同时会导致多重共线性的出现，实际只需要n-1个编码即可表示。因此也会在实际操作中先删去一维变量再进行编码
- Target Encoding(目标编码):当定性特征的维度（Cardinality）很大时，上述两种方法都不能实现很好的编码效果。此时需要通过Target encoding进行编码。以二分类数据集为例，target encoding对于某一特征取值的编码是在该取值的全部观测值中标签1出现的占比。对回归数据来说，encoding可以是在该分类取值下的目标均值。
  - 当极端情况出现时，该编码方法可能会导致数据泄露。如各个分类取值的比例和目标标签的相关性为1时可能会过拟合训练集输出的情况。

### Reference：

[贝叶斯优化深入理解](https://zhuanlan.zhihu.com/p/53826787)

[[数据分析] target encoding ](https://www.cnblogs.com/lryou/p/14627564.html)
